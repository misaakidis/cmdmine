#! /usr/bin/env python

import os
import re
import sys
import json
import math
import datetime
import click 
from redmine import Redmine

# Don't print warnings about unverified certs
import requests
requests.packages.urllib3.disable_warnings()

MACROS_FILE = os.sep.join([os.environ['HOME'], '.cmdmine', 'macros.json'])
ACTIVITY_FILE = os.sep.join([os.environ['HOME'], '.cmdmine', 'activities.json'])

## COMMAND TYPES

@click.group()
def cmdmine():
  pass

@cmdmine.group()
def new():
  pass

@cmdmine.group()
def update():
  pass

@cmdmine.group()
def list():
  pass

@cmdmine.group()
def delete():
  pass


## HELPER FUNCTIONS

def confirmed():
  '''Ask the user if they are sure they want to continue''' 
  answer = raw_input('Are you sure you want to proceed? [yes or no]: ').lower()
  return answer.startswith('y')

def load_configuration():
  '''Load the program's configuration'''
  if not os.path.isfile(CONFIG_FILE):
    click.echo('No configuration file found. Have you run the install.sh script?')
    sys.exit(1)
  try:
    cf = open(CONFIG_FILE, 'r')
    parsed = json.load(cf)
    cf.close()
    return parsed
  except Exception:
    click.echo('Could not successfully decode the configuration file.')
    click.echo('Please check that it is correctly formatted.')
    sys.exit(1)


# Load the program's configuration from a JSON file
# The config filename is stored for future convenience
CONFIG_FILE = os.sep.join([os.environ['HOME'], '.cmdmine', 'config.json'])
config = load_configuration()

def redmine_auth():
  '''Authenticate with and return a configured redmine object'''
  click.echo('Authenticating with redmine.')
  try:
    REDMINE = Redmine(config['redmine-location'],
      key=config['redmine-api-key'],
      requests={'verify': False}, raise_attr_exception=False)
  except Exception:
    click.echo('Failed to authenticate.\nQuitting.')
    sys.exit(1)
  click.echo('Authenticated.')
  return REDMINE


def build_projects(REDMINE):
  '''Collect information about projects aliased in the config'''
  click.echo('Collecting project information.')
  PROJECTS = { name: REDMINE.project.get(config['redmine-projects'][name])
              for name in config['redmine-projects'].keys() }
  click.echo('Done.')
  return PROJECTS


def log_activity(date, time, hours, minutes, project, issue, isubject, activity, comments):
  '''Write an activity entry to a log file for local reference'''
  logs = json.loads(open(ACTIVITY_FILE, 'r').read())
  print issue
  logs.append({
    "date": date,
    "time": time,
    "hours": hours,
    "minutes": minutes,
    "projectName": project,
    "issueId": issue,
    "issueName": str(isubject),
    "commitType": activity,
    "comment": str(comments)
  })
  open(ACTIVITY_FILE, 'w').write(json.dumps(logs))


def get_issue_info(macro_name):
  '''Returns the project name and issue ID for an issue assigned to a macro'''
  if not os.path.isfile(MACROS_FILE):
    return None, None
  macros = json.loads(open(MACROS_FILE, 'r').read())
  if macro_name not in macros.keys():
    return None, None
  return macros[macro_name]['project_name'], macros[macro_name]['issue_id']


def show_hours(since_date):
  '''Compute the number of hours worked since a particular date (or in total-None)'''
  if not os.path.isfile(ACTIVITY_FILE):
    click.echo('No activities logged yet.')
    return
  logs = json.loads(open(ACTIVITY_FILE, 'r').read())
  if since_date is not None:
    dt = datetime.datetime.strptime(since_date, '%Y-%m-%d')
  else:
    dt = datetime.datetime(1970, 1, 1, 0, 0, 0)
  logs = filter(
    lambda log: datetime.datetime.strptime(log['date'], '%Y-%m-%d') >= dt,
    logs)
  hours_spent = {} # Map project names to number of hours spent on that project
  # Keep track of the length of the longest project name for formatting later
  longest_proj_len = 0
  for log in logs:
    time_spent = log['hours'] + (log['minutes'] / 60.0)
    if log['projectName'] in hours_spent:
      hours_spend[log['projectName']] += time_spent
    else:
      hours_spent[log['projectName']] = time_spent
    if len(log['projectName']) > longest_proj_len:
      longest_proj_len = len(log['projectName'])
  click.echo('{0} Time Logged'.format('Project'.ljust(longest_proj_len)))
  click.echo('{0} -----------'.format('-------'.ljust(longest_proj_len)))
  total = 0
  for project in hours_spent.keys():
    click.echo('{0} hours {1}'.format(
      project.ljust(longest_proj_len),
      hours_spent[project]))
    total += hours_spent[project]
  hours = int(math.floor(total))
  minutes = int(math.ceil((total - hours) * 60))
  click.echo('-- Total: {0} hours, {1} minutes --'.format(hours, minutes))


## ISSUE COMMANDS

@new.command()
@click.argument('project', type=click.Choice(config['redmine-projects']))
@click.option('--subject', '-s', type=str,
  help='A descriptive subject for the new task')
@click.option('--priority', '-p', type=click.Choice(config['priorities']), default=config['default-priority'],
  help='The name of the priority to assign to the new task')
@click.option('--due', '-d', type=str,
  help='The due date of the task. Defaults to none. Format is YYYY-MM-DD')
@click.option('--time', '-t', type=int,
  help='The estimated number of hours required to complete the task')
@click.option('--description', '-D', type=str, default='No description provided.',
  help='A description to explain the task')
@click.option('--tracker', '-T', type=click.Choice(config['trackers']),
  default=config['default-tracker'],
  help='The name of the tracker to use for the task')
def issue(project, subject, priority, due, time, description, tracker):
  if subject is None:
    click.echo('No subject was provided for the task. Use the --subject or -s flag.')
    return
  due_date_str = str(due)
  try:
    if due is not None:
      due = datetime.datetime.strptime(due, '%Y-%m-%d')
  except ValueError:
    click.echo(due + ' is not a valid date. The format is YYYY-MM-DD')
    return
  priority = config['priorities'][priority]
  tracker_name = tracker
  tracker = config['trackers'][tracker]
  project = config['redmine-projects'][project]
  today = datetime.date.today().strftime('%Y-%m-%d')
  now = datetime.datetime.now().strftime('%H:%M')
  REDMINE = redmine_auth()
  issue = REDMINE.issue.create(
    project_id=project, subject=subject, tracker_id=tracker, description=description,
    status_id=config['new-task-status'], priority_id=priority, assigned_to_id=config['assignee-me'],
    start_date=today, due_date=due, estimated_hours=time,
    watcher_user_ids=[], parent_issue_id=-1, done_ratio=0, custom_fields=[], uploads=[])
  click.echo('Cmdmine is about to make the following change.') 
  click.echo('Create new {0} in project {1}: {2}\nDue date: {3}, Estimated time (hours): {4}.'.format(
    tracker_name, project, subject, due_date_str, str(time)))
  if not confirmed():
    click.echo('Aborting')
    return
  try:
    issue.save()
    log_activity(today, now, 0, 0, project, issue.id, subject, 'Create', 'Created new task')
  except Exception:
    pass # This call successfully creates an issue but throws some weird exception anyway. Dunno.
  click.echo('New issue id: {0}'.format(issue.id))


@update.command()
@click.option('--macro', '-m', type=str,
  help='The name of a macro referring to the issue to update')
@click.option('--issue', '-i', type=int,
  help='The ID of the issue to update')
@click.option('--project', '-p', type=click.Choice(config['redmine-projects']),
  help='The shorthand name of the project the issue to update belongs to')
@click.option('--status', '-s', type=click.Choice(config['statuses']),
  help='The new status for the issue')
@click.option('--priority', '-P', type=click.Choice(config['priorities']),
  help='The new priority for the issue')
@click.option('--done', '-d', type=click.IntRange(0, 100),
  help='The percentage of the task now complete')
@click.option('--due', '-D', type=str,
  help='A due date to assign to the issue, formatted YYYY-MM-DD')
def issue(macro, issue, project, status, priority, done, due):
  if macro is not None:
    project, issue = get_issue_info(macro)
  if (not project) or (not issue): # Either are empty or None
    click.echo('No information available about the issue specified.')
    return
  if due is not None:
    try:
      datetime.datetime.strptime(due, '%Y-%m-%d')
    except ValueError:
      click.echo('The due date {0} is not properly formatted YYYY-MM-DD'.format(due))
      return
  REDMINE = redmine_auth()
  args = {}
  if status is not None: args['status_id'] = config['statuses'][status]
  if priority is not None: args['priority_id'] = config['priorities'][priority]
  if done is not None: args['done_ratio'] = done
  if due is not None: args['due_date'] = due
  today = datetime.date.today().strftime('%Y-%m-%d')
  now = datetime.datetime.now().strftime('%H:%M')
  if not confirmed():
    click.echo('Aborting.')
    return
  try:
    isubject = REDMINE.issue.get(issue).subject
    log_activity(today, now, 0, 0, project, issue, isubject, 'Update', 'Updated issue')
  except Exception:
    click.echo('No issue with ID {0} exists. Aborting update.'.format(issue))
    return
  try:
    REDMINE.issue.update(issue, **args)
  except Exception as ex:
    pass # Seriously, why do all write operations raise an exception despite working fine?
  click.echo('Issue updated successfully.')


@list.command()
@click.argument('project', type=click.Choice(config['redmine-projects']))
@click.option('--limit', '-l', default=20,
  help='Limit the number of issues that will be reported')
@click.option('--offset', '-o', default=0,
  help='Offset from the first retrieved issue to report')
def issues(project, limit, offset):
  REDMINE = redmine_auth()
  PROJECTS = build_projects(REDMINE)
  matched_projects = [PROJECTS[name] for name in PROJECTS.keys() if project == name]
  issues = []
  longest_subject_length = 0
  click.echo('Collecting issue information.')
  for proj in matched_projects:
    for issue in proj.issues:
      issues.append(issue)
  # Find the length of the longest subject name so we can nicely format the output
  for issue in issues[offset : offset + limit + 1]:
    subject_length = len(issue.subject)
    if subject_length > longest_subject_length:
      longest_subject_length = subject_length
  longest_subject_length += 1
  click.echo('') # Print a nice blank line before our gorgeous table
  click.echo('ID     ' + 'Subject'.ljust(longest_subject_length) + ' Assigned to')
  click.echo('----   ' + '-------'.ljust(longest_subject_length) + ' -----------')
  for issue in issues[offset : offset + limit + 1]:
    click.echo(u'{0} - {1} {2}'.format(
      str(issue.id), (issue.subject + ' ').ljust(longest_subject_length, '-'), str(issue.assigned_to)))


@delete.command()
@click.option('--macro', '-m', type=str,
  help='The name of a macro identifying the issue to close')
@click.option('--project', '-p', type=click.Choice(config['redmine-projects']),
  help='The shorthand name for the project that the issue to close belongs to')
@click.option('--issue', '-i', type=int,
  help='The ID of the issue to close- must be provided if a macro is not')
def issue(macro, project, issue):
  if macro is not None:
    project, issue = get_issue_info(macro)
  if (not project) and (not issue): # Both are empty or None
    click.echo('No information available about the issue specified.')
    return
  REDMINE = redmine_auth()
  today = datetime.date.today().strftime('%Y-%m-%d')
  now = datetime.datetime.now().strftime('%H:%M')
  try:
    isubject = REDMINE.issue.get(issue).subject
    log_activity(today, now, 0, 0, project, issue, isubject, 'Update', 'Closing issue')
  except Exception:
    click.echo('No issue with ID {0} exists. Aborting update.'.format(issue))
    return
  click.echo('About to delete task: ' + isubject)
  if not confirmed():
    click.echo('Aborting.')
    return
  try:
    REDMINE.issue.update(issue, status_id=config['closed-status'])
  except Exception:
    pass
  click.echo('Issue closed successfully.')


## MACRO COMMANDS

@new.command()
@click.option('--issue', '-i', type=int,
  help='The ID of the issue to reference')
@click.option('--project', '-p', type=str,
  help='The shorthand name of the project to reference')
@click.argument('macro_name')
def macro(issue, project, macro_name):
  if not os.path.isfile(MACROS_FILE):
    macros = {}
  else:
    try:
      macros = json.loads(open(MACROS_FILE, 'r').read())
    except Exception:
      macros = {}
  macros[macro_name] = {'issue_id': issue, 'project_name': project}
  click.echo('Registered macro {0} for project {1}, issue {2}.'.format(
    macro_name, project, issue))
  open(MACROS_FILE, 'w').write(json.dumps(macros))
  click.echo('You now have {0} macros registered.'.format(len(macros.keys())))


@delete.command()
@click.argument('macro_name')
def macro(macro_name):
  try:
    macros = json.loads(open(MACROS_FILE, 'r').read())
    if macro_name in macros:
      del macros[macro_name]
      open(MACROS_FILE, 'w').write(json.dumps(macros))
      click.echo('Deleted macro {0}.'.format(macro_name))
    else:
      click.echo('NO such macro {0}.'.format(macro_name))
  except IOError:
    click.echo('You do not have any macros registered yet.')

@list.command()
def macros():
  if not os.path.isfile(MACROS_FILE):
    click.echo('You currently have no macros registered.')
    return
  try:
    macros = json.loads(open(MACROS_FILE, 'r').read()) 
  except Exception:
    click.echo('You currently have no macros registered.')
    return
  # Find the longest macro name and project name so we can format the output more nicely
  l_macro_len = len('macro') + 1
  l_project_len = len('project') + 1
  for macro_name in macros.keys():
    lmn = len(macro_name)
    lpn = len(macros[macro_name]['project_name'])
    l_macro_len = lmn if lmn > l_macro_len else l_macro_len
    l_project_len = lpn if lpn > l_project_len else l_project_len
  click.echo('{0} {1} Issue ID'.format('Macro'.ljust(l_macro_len), 'Project'.ljust(l_project_len)))
  click.echo('{0} {1} {2}'.format('-----'.ljust(l_macro_len), '-------'.ljust(l_project_len), '--------'))
  for macro_name in macros.keys():
    click.echo('{0} {1} {2}'.format(
      macro_name.ljust(l_macro_len),
      macros[macro_name]['project_name'].ljust(l_project_len),
      macros[macro_name]['issue_id']))


## LOG COMMANDS

@new.command()
@click.argument('activity', type=click.Choice(config['activities']))
@click.option('--project', '-p',
  help='The shorthand name of the project the issue belongs to')
@click.option('--issue', '-i', type=int,
  help='The ID of the issue to reference')
@click.option('--macro', '-m', type=str, default='',
  help='A macro identifier. If provided, the project name and issue ID fields are not required')
@click.option('--hours', '-H', type=int,
  help='The number of hours worked on the issue')
@click.option('--minutes', '-M', type=int,
  help='The number of minutes worked on the issue')
@click.option('--date', '-d', type=str,
  help='The date the work was done, formatted YYYY-MM-DD')
@click.option('--time', '-t', type=str,
  help='The time the work was done, formatted HH:MM')
@click.option('--comments', '-c', type=str,
  help='Commentary about the nature of the work done')
def log(activity, project, issue, macro, hours, minutes, date, time, comments):
  if len(macro) > 0:
    project, issue = get_issue_info(macro)
  if (not project) or (not issue): # Either are empty or None
    click.echo('No information available about the issue specified.')
    return
  if hours is None and minutes is None:
    click.echo('You must enter some number of hours (-H) and/or minutes (-M) to be logged.')
    return
  if date is None:
    date = datetime.date.today().strftime('%Y-%m-%d')
  if time is None:
    time = datetime.datetime.now().strftime('%H:%M')
  if hours is None:
    hours = 0
  if minutes is None:
    minutes = 0
  REDMINE = redmine_auth()
  time_spent = hours + (minutes / 60.0)
  time_entry = REDMINE.time_entry.create(
    issue_id=issue, spent_on=date, hours=time_spent,
    activity_id=config['activities'][activity], comments=str(comments))
  click.echo('Cmdmine is about to make the following change.')
  click.echo('Log {0} hours of work on issue {1}, project {2} at {3}.'.format(
    time_spent, issue, project, date))
  click.echo('Comment: ' + str(comments))
  if not confirmed():
    click.echo('Aborting')
    return
  try:
    time_entry.save()
  except Exception as e:
    pass # This works but for some reason throws an exception like saving a task does. Dunno why.
  issue_subject = REDMINE.issue.get(issue).subject
  log_activity(date, time, hours, minutes, project, issue, issue_subject, activity, comments)
  click.echo('Logged successfully.')


@list.command()
@click.option('--since', '-s', type=str,
  help='Start date from which to start counting hours worked. Format is YYYY-MM-DD')
def logs(since):
  if since is not None:
    show_hours(since)
    return
  if not os.path.isfile(ACTIVITY_FILE):
    click.echo('No activities logged yet.')
    return
  logs = json.loads(open(ACTIVITY_FILE, 'r').read())
  for log in logs:
    click.echo('''Committed {0} hours, {1} minutes of {2} to issue #{3} in {4} on {5} at {6}.
Issue: {7}
Comment: {8}
'''.format(
    log['hours'], log['minutes'], log['commitType'], log['issueId'],
    log['projectName'], log['date'], log['time'], log['issueName'], log['comment']))


if __name__ == '__main__':
  cmdmine()
