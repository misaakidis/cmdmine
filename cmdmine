#! /usr/bin/env python

import os
import re
import sys
import pickle
import datetime
import click 
from redmine import Redmine
from config import *

# Don't print warnings about unverified certs
import requests
requests.packages.urllib3.disable_warnings()

MACROS_FILE = 'macros.dat'
ACTIVITY_FILE = os.sep.join([os.environ['HOME'], '.cmdmine', 'activities.log'])


def redmine_auth():
  '''Authenticate with and return a configured redmine object'''
  click.echo('Authenticating with redmine.')
  try:
    REDMINE = Redmine(REDMINE_LOCATION,
      username=REDMINE_USERNAME, password=REDMINE_PASSWORD,
      requests={'verify': False}, raise_attr_exception=False)
  except Exception:
    click.echo('Failed to authenticate.\nQuitting.')
    sys.exit(1)
  click.echo('Authenticated.')
  return REDMINE


def build_projects(REDMINE):
  '''Collect information about projects aliased in the config'''
  click.echo('Collecting project information.')
  PROJECTS = { name: REDMINE.project.get(REDMINE_PROJECTS[name]) for name in REDMINE_PROJECTS.keys() }
  click.echo('Done.')
  return PROJECTS


def log_activity(date, time_spent, project, issue, activity, comments):
  '''Write an activity entry to a log file for local reference'''
  f = open(ACTIVITY_FILE, 'a')
  f.write('{0}@@{1} hours@@{2} issue #{3}@@{4}\n'.format(
    date, time_spent, project, issue, activity))
  f.write(str(comments) + '\n\n')
  f.close()


def get_issue_info(macro_name):
  '''Returns the project name and issue ID for an issue assigned to a macro'''
  if not os.path.isfile(MACROS_FILE):
    return None, None
  macro_file = open(MACROS_FILE, 'rb')
  macros = pickle.load(macro_file)
  macro_file.close()
  if macro_name not in macros.keys():
    return None, None
  return macros[macro_name]['project_name'], macros[macro_name]['issue_id']


def show_macros():
  '''List all currently registered macros'''
  if not os.path.isfile(MACROS_FILE):
    click.echo('You currently have no macros registered.')
    return
  macro_file = open(MACROS_FILE, 'rb')
  macros = pickle.load(macro_file)
  macro_file.close()
  click.echo('Macro\tProject\t\tIssue ID')
  for macro_name in macros.keys():
    click.echo('{0}\t{1}\t\t{2}'.format(
      macro_name, macros[macro_name]['project_name'], macros[macro_name]['issue_id']))


def show_logs():
  '''List all time log entries'''
  if not os.path.isfile(ACTIVITY_FILE):
    click.echo('No activities logged yet.')
    return
  log_file = open(ACTIVITY_FILE, 'r')
  for line in log_file:
    line = line.replace('@@', '\t').replace('\n', '', 1)
    click.echo(line)
  log_file.close()


@click.group()
def cmdmine():
  pass


@cmdmine.command()
@click.option('--issue', '-i', type=int,
  help='The ID of the issue to reference')
@click.option('--project', '-p', type=str,
  help='The shorthand name of the project to refence')
@click.argument('macro_name')
def macro(issue, project, macro_name):
  if not os.path.isfile(MACROS_FILE):
    macros = {}
  else:
    macro_file = open(MACROS_FILE, 'rb')
    macros = pickle.load(macro_file)
    macro_file.close()
  macro_file = open(MACROS_FILE, 'wb')
  macros[macro_name] = {'issue_id': issue, 'project_name': project}
  pickle.dump(macros, macro_file)
  macro_file.close()
  click.echo('Registered macro {0} for project {1} issue {2}.'.format(
    macro_name, project, issue))
  click.echo('You now have {0} macros registered.'.format(len(macros.keys())))


@cmdmine.command()
@click.argument('what', type=click.Choice(['macros', 'logs']))
def show(what):
  if what == 'macros':
    show_macros()
  else:
    show_logs()


@cmdmine.command()
@click.option('--project', '-p',
  help='The shorthand name of the project to search')
@click.option('--limit', '-l', default=20,
  help='Limit the number of issues that will be reported')
@click.option('--offset', '-o', default=0,
  help='Offset from the first retrieved issue to report')
def issues(project, limit, offset):
  REDMINE = redmine_auth()
  PROJECTS = build_projects(REDMINE)
  matched_projects = [PROJECTS[name] for name in PROJECTS.keys() if project == name]
  issues = []
  longest_subject_length = 0
  click.echo('Collecting issue information.')
  for proj in matched_projects:
    for issue in proj.issues:
      issues.append(issue)
  # Find the length of the longest subject name so we can nicely format the output
  for issue in issues[offset : offset + limit + 1]:
    subject_length = len(issue.subject)
    if subject_length > longest_subject_length:
      longest_subject_length = subject_length
  longest_subject_length += 1
  click.echo('ID' + (' ' * 5) + 'Subject'.ljust(longest_subject_length) + ' Assigned to')
  for issue in issues[offset : offset + limit + 1]:
    click.echo(u'{0} - {1} {2}'.format(
      str(issue.id), (issue.subject + ' ').ljust(longest_subject_length, '-'), str(issue.assigned_to)))


@cmdmine.command()
@cmdmine.argument('project', type=click.Choice(REDMINE_PROJECTS))
@cmdmine.option('--subject', '-s' type=str,
  help='A descriptive subject for the new task')
@cmdmine.option('--priority', '-p', type=click.Choice(PRIORITIES), default=DEFAULT_PRIORITY,
  help='The name of the priority to assign to the new task')
@cmdmine.option('--due', '-d', type=str,
  help='The due date of the task. Defaults to none. Format is YYYY-MM-DD')
@cmdmine.option('--time', '-t', type=int,
  help='The estimated number of hours required to complete the task')
@cmdmine.option('--description', '-D', type=str, default='No description provided.',
  help='A description to explain the task')
@cmdmine.option('--tracker', '-T', type=str, default=DEFAULT_TRACKER,
  help='The name of the tracker to use for the task')
def new_task(project, subject, priority, due, time, description, tracker):
  if subject is None:
    click.echo('No subject was provided for the task. Use the --subject or -s flag.')
    return
  due_date_str = str(due)
  try:
    if due is not None:
      due = datetime.strptime(due, '%Y-%m-%d')
  except ValueError:
    click.echo(due + ' is not a valid date. The format is YYYY-MM-DD')
    return
  priority = PRIORITIES[priority]
  tracker_name = tracker
  tracker = TRACKERS[tracker]
  project = REDMINE_PROJECTS[project]
  today = datetime.date.today().strftime('%Y-%m-%d')
  REDMINE = readmine_auth()
  issue = REDMINE.issue.create(
    project_id=project, subject=subject, tracker_id=tracker, description=description,
    status_id=NEW_TASK_STATUS, priority_id=priority, assigned_to_id=ASSIGNEE_ME,
    start_date=today, due_date=due, estimated_hours=time)
  issue.save()
  click.echo('Created new {0} in project {1}.\n{2}\nDue date: {3}, Estimated time (hours): {4}.'.format(
    tracker_name, project, subject, due_date_str, str(time)))


@cmdmine.command()
@click.argument('activity', type=click.Choice(ACTIVITIES))
@click.option('--project', '-p',
  help='The shorthand name of the project to update')
@click.option('--issue', '-i', type=int,
  help='The ID of the issue to reference')
@click.option('--macro', '-m', type=str, default='',
  help='A macro identifier. If provided, the project name and issue ID fields are not required')
@click.option('--hours', '-H', type=int,
  help='The number of hours worked on the issue')
@click.option('--minutes', '-M', type=int,
  help='The number of minutes worked on the issue')
@click.option('--date', '-d', type=str,
  help='The date the work was done, formatted YYYY-MM-DD')
@click.option('--comments', '-c', type=str,
  help='Commentary about the nature of the work done')
def log(activity, project, issue, macro, hours, minutes, date, comments):
  if len(macro) > 0:
    project, issue = get_issue_info(macro)
  if (not project) or (not issue): # Either are empty or None
    click.echo('No information available about the issue specified.')
    return
  if hours is None and minutes is None:
    click.echo('You must enter some number of hours (-H) and/or minutes (-M) to be logged.')
    return
  if date is None:
    date = datetime.date.today().strftime('%Y-%m-%d')
  REDMINE = redmine_auth()
  time_spent = hours + (minutes / 60.0)
  time_entry = REDMINE.time_entry.create(
    issue_id=issue, spent_on=date, hours=time_spent,
    activity_id=ACTIVITIES[activity], comments=str(comments))
  time_entry.save()
  log_activity(date, time_spent, project, issue, activity, comments)
  click.echo('Logged {0} hours of work on issue {1}, project {2} at {3}.'.format(
    time_spent, issue_id, project, date))
  click.echo('Comment: ' + str(comments))


if __name__ == '__main__':
  cmdmine()
