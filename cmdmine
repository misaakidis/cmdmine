#! /usr/bin/env python

import os
import re
import sys
import pickle
import click 
from redmine import Redmine
from config import *

# Don't print warnings about equalit.ie's unverified cert
import requests
requests.packages.urllib3.disable_warnings()

MACROS_FILE = 'macros.dat'

REDMINE = Redmine(REDMINE_LOCATION,
  username=REDMINE_USERNAME, password=REDMINE_PASSWORD,
  requests={'verify': False}, raise_attr_exception=False)

PROJECTS = { name: REDMINE.project.get(REDMINE_PROJECTS[name]) for name in REDMINE_PROJECTS.keys() }

@click.group()
def cmdmine():
  pass


@cmdmine.command()
@click.option('--issue', '-i', type=int,
  help='The ID of the issue to reference')
@click.option('--project', '-p', type=str,
  help='The shorthand name of the project to refence')
@click.argument('macro_name')
def macro(issue, project, macro_name):
  if not os.path.isfile(MACROS_FILE):
    macros = {}
  else:
    macro_file = open(MACROS_FILE, 'rb')
    macros = pickle.load(macro_file)
    macro_file.close()
  macro_file = open(MACROS_FILE, 'wb')
  macros[macro_name] = {'issue_id': issue, 'project_name': project}
  pickle.dump(macros, macro_file)
  macro_file.close()
  click.echo('Registered macro {0} for project {1} issue {2}'.format(
    macro_name, project, issue))
  click.echo('You now have {0} macros registered.'.format(len(macros.keys())))


@cmdmine.command()
def macros():
  if not os.path.isfile(MACROS_FILE):
    click.echo('You currently have no macros registered.')
    return
  macro_file = open(MACROS_FILE, 'rb')
  macros = pickle.load(macro_file)
  macro_file.close()
  click.echo('Macro\tProject\t\tIssue ID')
  for macro_name in macros.keys():
    click.echo('{0}\t{1}\t\t{2}'.format(
      macro_name, macros[macro_name]['project_name'], macros[macro_name]['issue_id']))


@cmdmine.command()
@click.option('--project', '-p', default='.*',
  help='The shorthand name of the project to search')
@click.option('--limit', '-l', default=20,
  help='Limit the number of issues that will be reported')
@click.option('--offset', '-o', default=0,
  help='Offset from the first retrieved issue to report')
def issues(project, limit, offset):
  matched_projects = [PROJECTS[name] for name in PROJECTS.keys() if project == name]
  issues = []
  for proj in matched_projects:
    for issue in proj.issues:
      issues.append(issue)
  click.echo('ID  Subject  Assigned to')
  for issue in issues[offset : offset + limit + 1]:
    click.echo(u' - '.join([str(issue.id), issue.subject, str(issue.assigned_to)]))


if __name__ == '__main__':
  cmdmine()
